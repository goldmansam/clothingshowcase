<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clothing Showcase</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    #canvas-container {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Scene setup
    const scene = new THREE.Scene();

    // Create premium gradient background
    const canvas = document.createElement('canvas');
    canvas.width = 2048;
    canvas.height = 2048;
    const ctx = canvas.getContext('2d');

    // Create vertical gradient (dark navy to lighter blue)
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#0a1628'); // Dark navy top
    gradient.addColorStop(0.5, '#1a2845'); // Mid blue
    gradient.addColorStop(1, '#2a3a5a'); // Lighter blue bottom

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const texture = new THREE.CanvasTexture(canvas);
    scene.background = texture;

    // Add atmospheric fog for depth
    scene.fog = new THREE.Fog(0x1a2845, 10, 35);

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 12); // Zoomed out view
    camera.lookAt(0, 0, 0); // Look at center of circle

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lighting - Enhanced for better visibility and color
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
    scene.add(ambientLight);

    // Hemisphere light for natural color rendering
    const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
    scene.add(hemisphereLight);

    // Main key light from front-top
    const keyLight = new THREE.DirectionalLight(0xffffff, 2.5);
    keyLight.position.set(0, 10, 10);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    scene.add(keyLight);

    // Fill light from left
    const fillLight = new THREE.DirectionalLight(0xffffff, 1.5);
    fillLight.position.set(-10, 5, 5);
    scene.add(fillLight);

    // Rim light from right
    const rimLight = new THREE.DirectionalLight(0xffffff, 1.5);
    rimLight.position.set(10, 5, -5);
    scene.add(rimLight);

    // Back light for depth
    const backLight = new THREE.DirectionalLight(0xffffff, 1.0);
    backLight.position.set(0, 3, -10);
    scene.add(backLight);

    // Bottom light to reduce harsh shadows
    const bottomLight = new THREE.DirectionalLight(0xffffff, 0.8);
    bottomLight.position.set(0, -10, 0);
    scene.add(bottomLight);

    // Add some colored accent lights
    const accentLight1 = new THREE.PointLight(0x4488ff, 0.5, 20);
    accentLight1.position.set(-8, 2, 0);
    scene.add(accentLight1);

    const accentLight2 = new THREE.PointLight(0xff8844, 0.5, 20);
    accentLight2.position.set(8, 2, 0);
    scene.add(accentLight2);

    // OrbitControls - disabled auto-rotate
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 3;
    controls.maxDistance = 15;
    controls.autoRotate = false;
    controls.enabled = false; // Disable controls entirely

    // Add brick ground plane
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load('mixed_brick_wall_diff_4k.jpg', (brickTexture) => {
      brickTexture.wrapS = THREE.RepeatWrapping;
      brickTexture.wrapT = THREE.RepeatWrapping;
      brickTexture.repeat.set(8, 8); // Tile more for smaller bricks

      const groundGeometry = new THREE.PlaneGeometry(30, 30);
      const groundMaterial = new THREE.MeshStandardMaterial({
        map: brickTexture,
        roughness: 0.8,
        metalness: 0.1,
        color: new THREE.Color(0.4, 0.4, 0.4) // Darken to 40% brightness
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
      ground.position.y = -1; // Position below models
      ground.receiveShadow = true;
      scene.add(ground);
      console.log('Brick ground added');
    });

    // Load Greek columns and place around the perimeter
    const columnLoader = new GLTFLoader();
    columnLoader.load('greek_column.glb', (gltf) => {
      const columnTemplate = gltf.scene;

      // Get column size to scale appropriately
      const box = new THREE.Box3().setFromObject(columnTemplate);
      const size = box.getSize(new THREE.Vector3());
      const scale = 24 / size.y; // Scale to 24 units tall (8x larger than original)
      columnTemplate.scale.setScalar(scale);

      // Place columns around the perimeter (30x30 plane)
      const planeSize = 30;
      const numColumnsPerSide = 4; // 4 columns per side
      const spacing = planeSize / (numColumnsPerSide - 1);

      const positions = [];

      // Front and back sides
      for (let i = 0; i < numColumnsPerSide; i++) {
        const x = -planeSize/2 + i * spacing;
        positions.push({ x: x, z: planeSize/2 });  // Front
        positions.push({ x: x, z: -planeSize/2 }); // Back
      }

      // Left and right sides (skip corners to avoid duplicates)
      for (let i = 1; i < numColumnsPerSide - 1; i++) {
        const z = -planeSize/2 + i * spacing;
        positions.push({ x: -planeSize/2, z: z }); // Left
        positions.push({ x: planeSize/2, z: z });  // Right
      }

      // Create a column at each position
      positions.forEach(pos => {
        const column = columnTemplate.clone();
        column.position.set(pos.x, -1, pos.z); // Same Y as ground
        column.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;

            // Make columns look more realistic - stone-like material
            if (child.material) {
              child.material = child.material.clone();
              child.material.color.setHex(0x8a8a8a); // Gray stone color
              child.material.roughness = 0.9; // Very rough, not shiny
              child.material.metalness = 0.0; // Not metallic at all
            }
          }
        });
        scene.add(column);
      });

      console.log(`Added ${positions.length} Greek columns`);
    });

    // Load models
    const loader = new GLTFLoader();
    const models = [];
    const modelFiles = [
      'Love (Final).gltf',
      'Pink Floyd (Final).gltf',
      'Purple Crown (Final).gltf',
      'Skyline Final.gltf',
      'Yellow Brick (final).gltf'
    ];

    let loadedCount = 0;

    modelFiles.forEach((file, index) => {
      loader.load(
        file,
        (gltf) => {
          const model = gltf.scene;

          // Stop any built-in animations
          if (gltf.animations && gltf.animations.length > 0) {
            console.log(`${file} has ${gltf.animations.length} animations (not playing)`);
          }

          // Center and scale model to uniform height
          const box = new THREE.Box3().setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());

          // Scale based on HEIGHT only (Y axis) to ensure all models same height
          const targetHeight = 2; // Target height for all models
          let scale = targetHeight / size.y;

          // Make Pink Floyd 5% bigger
          if (file === 'Pink Floyd (Final).gltf') {
            scale *= 1.05;
          }

          model.scale.setScalar(scale);

          // Center the model at origin
          model.position.x = -center.x * scale;
          model.position.y = -center.y * scale;
          model.position.z = -center.z * scale;

          // Create a container/group for this model
          const container = new THREE.Group();
          container.add(model);

          // Position the CONTAINER, not the model
          const spacing = 3;
          const offset = -(modelFiles.length - 1) * spacing / 2;
          container.position.set(offset + index * spacing, 0, 0);

          // Enable shadows
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });

          // Add dramatic spotlight above each model
          const spotlight = new THREE.SpotLight(0xffffff, 3);
          spotlight.position.set(0, 8, 0);
          spotlight.angle = Math.PI / 6; // 30 degree cone
          spotlight.penumbra = 0.3; // Soft edges
          spotlight.decay = 2;
          spotlight.distance = 20;
          spotlight.castShadow = true;
          spotlight.shadow.mapSize.width = 1024;
          spotlight.shadow.mapSize.height = 1024;
          spotlight.target = container;
          container.add(spotlight);
          scene.add(spotlight.target);

          scene.add(container);
          models.push(container);

          loadedCount++;
          console.log(`Loaded ${loadedCount}/${modelFiles.length} models`);
        },
        (progress) => {
          console.log(`Loading ${file}: ${(progress.loaded / progress.total * 100).toFixed(0)}%`);
        },
        (error) => {
          console.error(`Error loading ${file}:`, error);
        }
      );
    });

    // Animation
    let time = 0;
    const circleRadius = 5; // Radius of circular path
    const circleSpeed = 0.005; // Speed of circular motion

    function animate() {
      requestAnimationFrame(animate);

      time += circleSpeed;

      // Move models in circular path AND rotate on their Y axis
      models.forEach((model, index) => {
        // Calculate angle for this model's position on the circle
        const angleOffset = (index / models.length) * Math.PI * 2; // Evenly space models
        const angle = time + angleOffset;

        // Position on circular path
        model.position.x = Math.cos(angle) * circleRadius;
        model.position.z = Math.sin(angle) * circleRadius;

        // Rotate model on its own Y axis
        model.rotation.y += 0.01;
      });

      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
